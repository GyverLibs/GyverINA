#ifndef _INA226_h
#define _INA226_h
#include <Wire.h>
#include <Arduino.h>

/*
Конструктор:	
    INA226 ina226 (Сопротивление шунта, Максимальный ожидаемый ток, Адрес на шине I2c)
    
    INA226 ina226;						// Стандартные значения для модуля INA226 (0.1 Ом, 0.8 А, адрес 0x40) - подойдет для одного модуля
    INA226 ina226 (0x41);				// Шунт и макс. ток по умолчанию, адрес 0x41 - подойдет для нескольких модулей
    INA226 ina226 (0.05f);				// Шунт 0.05 Ом, макс. ток и адрес по умолчанию (0.8 А, 0x40) - Допиленный модуль или голая м/с
    INA226 ina226 (0.05f, 1.5f);		// Шунт 0.05 Ома, макс. ожидаемый ток 1.5 А, адрес по умолчанию (0x40) - Допиленный модуль или голая м/с
    INA226 ina226 (0.05f, 1.5f, 0x41);	// Шунт 0.05 Ома, макс. ожидаемый ток 1.5 А, адрес 0x41  - Допиленные модули или голые м/с
    
Методы:
    bool begin();							    // Инициализация модуля и проверка присутствия, вернет false если INA226 не найдена
    void sleep(true / false);				    // Включение и выключение режима низкого энергопотребления, в зависимости от аргумента
    void setAveraging(avg);					    // Установка количества усреднений измерений (см. таблицу ниже)
    void setSampleTime(ch, time);			    // Установка времени выборки напряжения и тока (INA226_VBUS / INA226_VSHUNT), по умолчанию INA226_CONV_1100US
        
    float getShuntVoltage(); 				    // Прочитать напряжение на шунте
    float getVoltage();	 					    // Прочитать напряжение
    float getCurrent();  					    // Прочитать ток
    float getPower(); 						    // Прочитать мощность
    
    uint16_t getCalibration();	 			    // Прочитать калибровочное значение (после старта рассчитывается автоматически)
    void setCalibration(calibration value);	    // Записать калибровочное значение 	(можно хранить его в EEPROM)	 		
    void adjCalibration(calibration offset);    // Подкрутить калибровочное значение на указанное значение (можно менять на ходу)
    
    Версия 1.0 от 31.10.2021
*/

/* Public-определения (константы) */
#define INA226_VBUS           true    // Канал АЦП, измеряющий напряжение шины (0-36в)
#define INA226_VSHUNT         false   // Канал АЦП, измеряющий напряжение на шунте

#define INA226_CONV_140US     0b000   // Время выборки (накопления сигнала для оцифровки)
#define INA226_CONV_204US     0b001
#define INA226_CONV_332US     0b010
#define INA226_CONV_588US     0b011
#define INA226_CONV_1100US    0b100
#define INA226_CONV_2116US    0b101
#define INA226_CONV_4156US    0b110
#define INA226_CONV_8244US    0b111

#define INA226_AVG_X1         0b000   // Встроенное усреднение (пропорционально увеличивает время оцифровки)
#define INA226_AVG_X4         0b001
#define INA226_AVG_X16        0b010
#define INA226_AVG_X64        0b011
#define INA226_AVG_X128       0b100
#define INA226_AVG_X256       0b101
#define INA226_AVG_X512       0b110
#define INA226_AVG_X1024      0b111

#ifndef INA226_VBUS_MULTIPLIER
#define INA226_VBUS_MULTIPLIER 1.0f     // Множитель для напряжения при использовании делителя напряжения на выходах шунта, задавать до подключения GyverINA.h
#endif

/* Private-определения (адреса) */
#define INA226_CFG_REG_ADDR   0x00
#define INA226_SHUNT_REG_ADDR 0x01
#define INA226_VBUS_REG_ADDR  0x02
#define INA226_POWER_REG_ADDR 0x03
#define INA226_CUR_REG_ADDR   0x04
#define INA226_CAL_REG_ADDR   0x05

class INA226 {
public:
    INA226(const float r_shunt = 0.1f, const float i_max = 0.8f, const uint8_t address = 0x40)
    : _r_shunt(r_shunt), _i_max(i_max), _iic_address(address) {}

    INA226(const uint8_t address)
    : _r_shunt(0.1f), _i_max(0.8f), _iic_address(address) {}
    
    // Инициализация и проверка
    bool begin(void) {
        Wire.begin();                           // Инициализация шины I2c
        if (!testConnection()) return false;    // Проверка присутствия
        calibrate();                            // расчёт калибровочного значения и инициализация
        return true;                            // Вернуть true если все ок
    }
    
    // Установка / снятие режима сна
    void sleep(bool state) {
        uint16_t cfg_register = readRegister(INA226_CFG_REG_ADDR) & ~(0b111);       // Прочитать конф. регистр и стереть биты режима
        writeRegister(INA226_CFG_REG_ADDR, cfg_register | (state ? 0b000 : 0b111)); // Записать новое значение конф. регистра с выбранным режимом
    }
    
    // Подстройка калибровочного значения
    void adjCalibration(int16_t adj) {
        setCalibration(getCalibration() + adj);     // Читаем и модифицируем значение
        _cal_value = _cal_value + adj;              // Обновляем внутреннюю переменную
    }
    
    // Установка калибровочного значения
    void setCalibration(uint16_t cal) {
        writeRegister(INA226_CAL_REG_ADDR, cal);    // Пишем значение в регистр калибровки
        _cal_value = cal;                           // Обновляем внутреннюю переменную
    }
    
    // Чтение калибровочного значения
    uint16_t getCalibration(void) {
        _cal_value = readRegister(INA226_CAL_REG_ADDR);     // Обновляем внутреннюю переменну
        return _cal_value;                                  // Возвращаем значение
    }
    
    // Установка встроенного усреднения выборок
    void setAveraging(uint8_t avg) {
        uint16_t cfg_register = readRegister(INA226_CFG_REG_ADDR) & ~(0b111 << 9);  // Читаем конф. регистр, сбросив биты AVG2-0
        writeRegister(INA226_CFG_REG_ADDR, cfg_register | avg << 9);                // Пишем новое значение конф. регистр
    }
    
    // Установка разрешения для выбранного канала
    void setSampleTime(bool ch, uint8_t mode) {
        uint16_t cfg_register = readRegister(INA226_CFG_REG_ADDR);  // Читаем конф. регистр
        cfg_register &= ~ ((0b111) << (ch ? 6 : 3));                // Сбрасываем нужную пачку бит, в зависимости от канала
        cfg_register |= mode << (ch ? 6 : 3);                       // Пишем нужную пачку бит, в зависимости от канала
        writeRegister(INA226_CFG_REG_ADDR, cfg_register);           // Пишем новое значение конф. регистра
    }
    
    // Чтение напряжения на шунте
    float getShuntVoltage(void) {
        setCalibration(_cal_value);                             // Принудительное обновление калибровки (на случай внезапного ребута INA219)
        int16_t value = readRegister(INA226_SHUNT_REG_ADDR);    // Чтение регистра напряжения шунта
        return value * 0.0000025f;                              // LSB = 2.5uV = 0.0000025V, умножаем и возвращаем
    }
    
    // Чтение напряжения
    float getVoltage(void) {
        uint16_t value = readRegister(INA226_VBUS_REG_ADDR);    // Чтение регистра напряжения
        return value * 0.00125f * INA226_VBUS_MULTIPLIER;       // LSB = 1.25mV = 0.00125V, Сдвигаем значение до 12 бит и умножаем
    }
    
    // Чтение тока
    float getCurrent(void) {
        setCalibration(_cal_value);                             // Принудительное обновление калибровки (на случай внезапного ребута INA219)
        int16_t value = readRegister(INA226_CUR_REG_ADDR);      // Чтение регистра тока
        return value * _current_lsb;                            // LSB рассчитывается на основе макс. ожидаемого тока, умножаем и возвращаем
    }
    
    // Чтение мощности
    float getPower(void) {
        setCalibration(_cal_value);                             // Принудительное обновление калибровки (на случай внезапного ребута INA219)
        uint16_t value = readRegister(INA226_POWER_REG_ADDR);   // Чтение регистра мощности
        return value * _power_lsb * INA226_VBUS_MULTIPLIER;     // LSB в 25 раз больше LSB для тока, умножаем возвращаем
    }

private:
    const uint8_t _iic_address = 0x00;  // Адрес на шине I2c
    const float _r_shunt = 0.0;         // Сопротивление шунта
    const float _i_max = 0.0;           // Макс. ожидаемый ток

    float _current_lsb = 0.0;           // LSB для тока
    float _power_lsb = 0.0;             // LSB для мощности
    uint16_t _cal_value = 0;            // Калибровочное значение
    
    // Запись 16-ти битного регистра INA219
    void writeRegister(uint8_t address, uint16_t data) {
        Wire.beginTransmission(_iic_address);   // Начинаем передачу
        Wire.write(address);                    // Отправляем адрес
        Wire.write(highByte(data));             // Отправляем старший байт
        Wire.write(lowByte(data));              // Отправляем младший байт
        Wire.endTransmission();                 // Заканчиваем передачу
    }
    
    // Чтение 16-ти битного регистра INA219
    uint16_t readRegister(uint8_t address) {
        Wire.beginTransmission(_iic_address);   // Начинаем передачу
        Wire.write(address);                    // Отправляем адрес
        Wire.endTransmission();                 // Заканчиваем передачу
        Wire.requestFrom(_iic_address, (uint8_t)2); // Запрашиваем 2 байта
        return Wire.read() << 8 | Wire.read();  // Клеим и возвращаем результат
    }
    
    // Проверка присутствия
    bool testConnection(void) {
        Wire.beginTransmission(_iic_address);   // Начинаем передачу
        return (bool)!Wire.endTransmission();   // Сразу заканчиваем, инвертируем результат
    }
    
    // Процедура расчёта калибровочного значения и инициализации
    void calibrate(void) {
        writeRegister(INA226_CFG_REG_ADDR, 0x8000);                 // Принудительный сброс

        _current_lsb = _i_max / 32768.0f;                           // расчёт LSB для тока (см. доку INA219)
        _power_lsb = _current_lsb * 25.0f;                          // расчёт LSB для мощности (см. доку INA219)
        _cal_value = trunc(0.00512f / (_current_lsb * _r_shunt));   // расчёт калибровочного значения (см. доку INA219)

        setCalibration(_cal_value);                                 // Записываем стандартное калибровочное значение
    }
};
#endif
